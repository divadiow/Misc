/*
 * FreeRTOS Kernel V10.1.1
 * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software. If you wish to use our Amazon
 * FreeRTOS name, please do so in a fair use way that does not cause confusion.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/*-----------------------------------------------------------
 * Implementation of functions defined in portmacro.h for the NDS32 port.
 *----------------------------------------------------------*/

/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "ISR_Support.h"
#include "chip_irqvector.h"
#include "chip_memmap.h"
#include "chip_clk_ctrl.h"
#include "arch_irq.h"
#include "arch_defs.h"
#include "pit.h"
#include "oshal.h"
#include "debug_core.h"

#ifndef configMAX_API_CALL_INTERRUPT_PRIORITY
	#define configMAX_API_CALL_INTERRUPT_PRIORITY
	#error configMAX_API_CALL_INTERRUPT_PRIORITY must be defined.
#endif

#if( ( configMAX_API_CALL_INTERRUPT_PRIORITY > 3 ) || ( configMAX_API_CALL_INTERRUPT_PRIORITY < 0 ) )
	#error configMAX_API_CALL_INTERRUPT_PRIORITY must be between 0 and 3
#endif

#ifndef configIRQ_SWI_VECTOR
	#error configIRQ_SWI_VECTOR must be defined in FreeRTOSConfig.h to have SWI to perform context switch.
#endif




/* Constants required to set up the initial stack. */
#define portPSW_GIE			( 1UL << 0UL )
#define portPSW_AEN			( 1UL << 13UL )
#define portPSW_IFCON			( 1UL << 15UL )
#define portPSW_CPL			( 7UL << 16UL )

#if ( configSUPPORT_ZOL == 1 )
	/* Default task PSW: enable GIE and AEN, set CPL to 7, clear IFCON */
	#define portINITIAL_PSW			( ( __nds32__mfsr( NDS32_SR_PSW ) | portPSW_GIE | portPSW_CPL | portPSW_AEN ) & ~portPSW_IFCON )
#else
	/* Default task PSW: enable GIE, set CPL to 7, clear IFCON */
	#define portINITIAL_PSW			( ( __nds32__mfsr( NDS32_SR_PSW ) | portPSW_GIE | portPSW_CPL ) & ~portPSW_IFCON )
#endif

/*-----------------------------------------------------------*/

/* Each task maintains its own interrupt status in the critical nesting
variable. */
static volatile UBaseType_t uxCriticalNesting 	= 	0x0;
static volatile unsigned int ulCriticalNestPsw 	=	0xaaaaaaaa;
#if( configUSE_TICKLESS_IDLE == 1 )
	/* Flag set from the tick interrupt to allow the sleep processing to know if
	sleep mode was exited because of a tick interrupt, or an interrupt
	generated by something else. */
	static volatile BaseType_t xTickFlag = pdFALSE;
#endif /* configUSE_TICKLESS_IDLE */

/*-----------------------------------------------------------*/

/*
 * Start first task is a separate function so it can be tested in isolation.
 */
extern void vPortStartFirstTask( void );

/*
 * Used to catch tasks that attempt to return from their implementing function.
 */
//static void prvTaskExitError( void );
static void prvTaskExitNormal( void );
void vConfigureTickInterrupt( void );

/*-----------------------------------------------------------*/

/*
 * Initialise the stack of a task to look exactly as if a call to
 * portSAVE_CONTEXT had been called.
 *
 * Stack Layout:
 *                High  |-----------------|
 *                      |       $R30 (LP) |
 *                      |-----------------|
 *                      |       $R29 (GP) |
 *                      |-----------------|
 *                      |       $R28 (FP) |
 *                      |-----------------|
 *                      |   $R15 | $R25   |
 *                      |-----------------|
 *                      |   $R10 | $R24   |
 *                      |-----------------|
 *                      |        .        |
 *                      |        .        |
 *                      |-----------------|
 *                      |       $R0       |
 *                      |-----------------|
 *                      |       $IFC_LP   | ( configSUPPORT_IFC )
 *                      |-----------------|
 *                      |   $LC/$LE/$LB   | ( configSUPPORT_ZOL )
 *                      |       (ZOL)     |
 *                      |-----------------|
 *                      |       $IPSW     |
 *                      |-----------------|
 *                      |       $IPC      |
 *                      |-----------------|
 *                      |    Dummy word   | ( Dummy word for 8-byte stack pointer alignment )
 *                      |-----------------|
 *                      |       $FPU      | ( configSUPPORT_FPU )
 *                      |-----------------|
 *                Low
 *
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
extern uint32_t _SDA_BASE_ __attribute__ ((weak));

	/* R0 ~ R30 registers */
	*--pxTopOfStack = ( StackType_t ) prvTaskExitNormal;/* R30 : $lp */
	*--pxTopOfStack = ( StackType_t ) &_SDA_BASE_;	/* R29 : $GP */
	*--pxTopOfStack = ( StackType_t ) 0x1c;		/* R28 */
#ifdef __NDS32_REDUCE_REGS__
	*--pxTopOfStack = ( StackType_t ) 0x0f;		/* R15 */
#else
	*--pxTopOfStack = ( StackType_t ) 0x19;		/* R25 */
	*--pxTopOfStack = ( StackType_t ) 0x18;		/* R24 */
	*--pxTopOfStack = ( StackType_t ) 0x17;		/* R23 */
	*--pxTopOfStack = ( StackType_t ) 0x16;		/* R22 */
	*--pxTopOfStack = ( StackType_t ) 0x15;		/* R21 */
	*--pxTopOfStack = ( StackType_t ) 0x14;		/* R20 */
	*--pxTopOfStack = ( StackType_t ) 0x13;		/* R19 */
	*--pxTopOfStack = ( StackType_t ) 0x12;		/* R18 */
	*--pxTopOfStack = ( StackType_t ) 0x11;		/* R17 */
	*--pxTopOfStack = ( StackType_t ) 0x10;		/* R16 */
	*--pxTopOfStack = ( StackType_t ) 0x0f;		/* R15 */
	*--pxTopOfStack = ( StackType_t ) 0x0e;		/* R14 */
	*--pxTopOfStack = ( StackType_t ) 0x0d;		/* R13 */
	*--pxTopOfStack = ( StackType_t ) 0x0c;		/* R12 */
	*--pxTopOfStack = ( StackType_t ) 0x0b;		/* R11 */
#endif
	*--pxTopOfStack = ( StackType_t ) 0x0a;		/* R10 */
	*--pxTopOfStack = ( StackType_t ) 0x09;         /* R9 */
	*--pxTopOfStack = ( StackType_t ) 0x08;		/* R8 */
	*--pxTopOfStack = ( StackType_t ) 0x07;		/* R7 */
	*--pxTopOfStack = ( StackType_t ) 0x06;		/* R6 */
	*--pxTopOfStack = ( StackType_t ) 0x05;		/* R5 */
	*--pxTopOfStack = ( StackType_t ) 0x04;		/* R4 */
	*--pxTopOfStack = ( StackType_t ) 0x03;		/* R3 */
	*--pxTopOfStack = ( StackType_t ) 0x02;		/* R2 */
	*--pxTopOfStack = ( StackType_t ) 0x01;		/* R1 */
	*--pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 : Argument */

#if ( configSUPPORT_IFC == 1 )
	/* IFC system register */
	*--pxTopOfStack = ( StackType_t ) 0x00;		/* IFC_LP */
#endif

#if ( configSUPPORT_ZOL == 1 )
	/* ZOL system registers */
	*--pxTopOfStack = ( StackType_t ) 0x00;		/* LC */
	*--pxTopOfStack = ( StackType_t ) 0x00;		/* LE */
	*--pxTopOfStack = ( StackType_t ) 0x00;		/* LB */
#endif

	/* IPSW and IPC system registers */
	*--pxTopOfStack = ( StackType_t ) portINITIAL_PSW;	/* IPSW */
	*--pxTopOfStack = ( StackType_t ) pxCode;		/* IPC : First instruction PC of task */

#if ( ( configSUPPORT_IFC == 1 ) && ( configSUPPORT_ZOL == 1 ) || ( configSUPPORT_IFC != 1 ) && ( configSUPPORT_ZOL != 1 ) )
	/* Dummy word for 8-byte stack alignment */
	*--pxTopOfStack = (portSTACK_TYPE) -1;
#endif

#if ( configSUPPORT_FPU == 1 )
	/* FPU registers */
	pxTopOfStack -= portFPU_REGS;
#endif

	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

#if 0
static void prvTaskExitError( void )
{
	/* A function that implements a task must not exit or attempt to return to
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	for( ;; );
}
#endif

static void prvTaskExitNormal( void )
{
	//os_printf(LM_CMD,LL_INFO,"task exit normal ~\n");
	vTaskDelete(NULL);
}


/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make Software interrupt the lowest priority interrupts. */
#if ( configIRQ_SWI_VECTOR < 16 )
	__nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_PRI ) | ( 3 << ( ( configIRQ_SWI_VECTOR ) << 1 ) ), NDS32_SR_INT_PRI );
#else
	__nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_PRI2 ) | ( 3 << ( ( ( configIRQ_SWI_VECTOR ) - 16 ) << 1 ) ), NDS32_SR_INT_PRI2 );
#endif
	__nds32__mtsr( __nds32__mfsr( NDS32_SR_INT_MASK2 ) | ( 1 << ( configIRQ_SWI_VECTOR ) ), NDS32_SR_INT_MASK2 );

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	/* Call an application function to set up the timer that will generate the
	tick interrupt.  This way the application can decide which peripheral to
	use.  A demo application is provided to show a suitable example. */
	vConfigureTickInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	ulCriticalNestPsw = 0;

	/* Start the first task. */
	vPortStartFirstTask();

	/* Should not get here! */
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
	/* Not implemented in ports where there is nothing to return to.
	Artificially force an assert. */
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

#ifdef CONFIG_SYSTEM_IRQ
void vPortEnterCritical(unsigned int irq_func, unsigned int irq_line)
{
	volatile unsigned int ulPsw = __nds32__mfsr(NDS32_SR_PSW);
	
	portDISABLE_INTERRUPTS();
	if( 0 == uxCriticalNesting)
	{
		ulCriticalNestPsw=ulPsw;
	}
	uxCriticalNesting++;
	system_irq_save_hook(irq_func, irq_line);
}

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	system_irq_restore_hook();
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		if(ulCriticalNestPsw & PSW_mskGIE)
		{
			portENABLE_INTERRUPTS();
		}
	}
}
#else
void vPortEnterCritical( void )
{
	volatile unsigned int ulPsw = __nds32__mfsr(NDS32_SR_PSW);

	portDISABLE_INTERRUPTS();
	if(0==uxCriticalNesting)
	{
		ulCriticalNestPsw=ulPsw;
	}
	uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		if(ulCriticalNestPsw&PSW_mskGIE)
		{
			portENABLE_INTERRUPTS();
		}
	}
}
/*-----------------------------------------------------------*/
#endif



#if 0
void portDISABLE_INTERRUPTS()
{
	uint32_t ulPSW = __nds32__mfsr( NDS32_SR_PSW );
	__nds32__gie_dis();
	#if 0
	if(ulPSW&PSW_mskGIE)
	{
		irq_status_track(0);
	}
	#endif
}
void portENABLE_INTERRUPTS()
{	
	uint32_t ulPSW = __nds32__mfsr( NDS32_SR_PSW );
	if(0 == (ulPSW&PSW_mskGIE))
	{
		irq_status_track(1);
	}
	__nds32__gie_en();
}
#endif

#if defined(CONFIG_OS_TICK_COMPENSTATION)
void portDISABLE_INTERRUPTS_TICK_COMPENSATION()
{
	uint32_t ulPSW = __nds32__mfsr( NDS32_SR_PSW );
	__nds32__gie_dis();
	if(ulPSW&PSW_mskGIE)
	{
		irq_status_track(0);
	}
}
void portENABLE_INTERRUPTS_TICK_COMPENSATION()
{	
	uint32_t ulPSW = __nds32__mfsr( NDS32_SR_PSW );
	if(0 == (ulPSW&PSW_mskGIE))
	{
		irq_status_track(1);
	}
	__nds32__gie_en();
}
#endif


/*-----------------------------------------------------------*/


void FreeRTOS_Tick_Handler( void );

/*
 * The application must provide a function that configures a peripheral to
 * create the FreeRTOS tick interrupt, then define configSETUP_TICK_INTERRUPT()
 * in FreeRTOSConfig.h to call the function. This file contains a function
 * that is suitable for use on the Andes AE210P.
 */
void vConfigureTickInterrupt( void )
{
	arch_irq_unmask(VECTOR_NUM_PIT1);

	/*  Set timer  as system tick by default  */
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_SET_COUNT, CHIP_CLOCK_APB / configTICK_RATE_HZ);
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_INTR_ENABLE, DRV_PIT_INTR_ENABLE);
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_CH_MODE_SET, DRV_PIT_CH_MODE_SET_TIMER);
	
	/*    tick ISR init 	 */
	arch_irq_clean(VECTOR_NUM_PIT1);
	arch_irq_unmask(VECTOR_NUM_PIT1);			
	arch_irq_register(VECTOR_NUM_PIT1, FreeRTOS_Tick_Handler);

	/* start timer */
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_CH_MODE_ENABLE, DRV_PIT_CH_MODE_ENABLE_TIMER);
}


void vClearTickInterrupt( void )
{
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_INTR_STATUS_CLEAN, 0);
	arch_irq_clean(VECTOR_NUM_PIT1);
}

void vEnableTickInterrupt( long xEnable )
{
	if (xEnable == pdTRUE)
	{
		drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_CH_MODE_ENABLE, DRV_PIT_CH_MODE_ENABLE_TIMER);
	}
	else
	{
		drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_CH_MODE_ENABLE, DRV_PIT_CH_MODE_ENABLE_NONE);
	}
}

void vSetTickReload( uint32_t ulReload )
{
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_SET_COUNT, ulReload);
}
/*-----------------------------------------------------------*/

uint32_t ulGetTickCounter( void )
{
	uint32_t ret;
	drv_pit_ioctrl(DRV_PIT_CHN_6, DRV_PIT_CTRL_GET_COUNT, (unsigned int)&ret);
	return ret;
}


void FreeRTOS_Tick_Handler( void )
{
	#ifdef CONFIG_SYSTEM_IRQ
	system_irq_save_hook((unsigned int)__FUNCTION__, __LINE__);
	#endif
	
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked. */
	uint32_t ulPreviousMask;

	vClearTickInterrupt();
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
		{
			/* A context switch is required.  Context switching is performed in
			the SWI interrupt.  Pend the SWI interrupt. */
			portYIELD();
		}

		#if( configUSE_TICKLESS_IDLE == 1 )
			xTickFlag = pdTRUE;
		#endif /* configUSE_TICKLESS_IDLE */
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );

	#ifdef CONFIG_SYSTEM_IRQ
	system_irq_restore_hook();
	#endif
}
/*-----------------------------------------------------------*/

#if ( configUSE_IDLE_HOOK == 1 )

	__attribute__((weak)) void vApplicationIdleHook( void )
	{
	}
#endif

/*-----------------------------------------------------------*/

#if( configUSE_TICKLESS_IDLE == 1 )
	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
	{
	#if 0
		/* The number of Timer's cycle that make up one tick period. */
		#define portUL_TIMER_COUNTS_FOR_ONE_TICK ( (uint32_t)( configPERIPHERAL_CLOCK_HZ / configTICK_RATE_HZ ) )

		/* The maximum number of tick periods that can be suppressed is limited by the
		resolution of the Timer. */
		#define portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS ( ( UINT32_MAX - 1 ) / portUL_TIMER_COUNTS_FOR_ONE_TICK )

		/* Compensate for the CPU cycles that pass while the Timer is stopped/disabled */
		#define portUL_STOPPED_TIMER_COMPENSATION ( (uint32_t) 0 )

		uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
		TickType_t xModifiableIdleTime;

		/* Make sure the Timer reload value does not overflow the Timer resolution. */
		if( xExpectedIdleTime > portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
		{
			xExpectedIdleTime = portMAXIMUM_POSSIBLE_SUPPRESSED_TICKS;
		}

		/* Read the Timer counter and then stop(disable) the Timer momentarily.
		The time the Timer is stopped for is accounted for as best it can be,
		but using the tickless mode will inevitably result in some tiny drift of
		the time maintained by the kernel with respect to calendar time. */
		uint32_t ulRemainTimerCounts = ulGetTickCounter();
		__nds32__gie_dis();
		uint32_t ulRemainTimerCounts2 = ulGetTickCounter();

		if( ulRemainTimerCounts2 > ulRemainTimerCounts )
		{
			/* Timer overflow occurs between 2 ulGetTickCounter() calls. */

			/* Enable interrupts to allow the Timer interrupt to execute
			immediately. */
			__nds32__gie_en();

			/* Read the Timer counter after Timer overflow. */
			ulRemainTimerCounts = ulGetTickCounter();

			/* Stop Timer. */
			vEnableTickInterrupt( pdFALSE );
		}
		else
		{
			/* Stop Timer. */
			vEnableTickInterrupt( pdFALSE );

			/* Clear Timer interrupt which occurs after 2nd
			ulGetTickCounter() call. */
			vClearTickInterrupt();

			/* Enable interrupts. */
			__nds32__gie_en();
		}

		/* Calculate the reload value required to wait xExpectedIdleTime
		tick periods. -1 is used because this code will execute part way
		through one of the tick periods. */
		ulReloadValue = ulRemainTimerCounts + ( portUL_TIMER_COUNTS_FOR_ONE_TICK * ( xExpectedIdleTime - 1UL ) );
		if( ulReloadValue > portUL_STOPPED_TIMER_COMPENSATION )
		{
			ulReloadValue -= portUL_STOPPED_TIMER_COMPENSATION;
		}

		/* Enter a critical section but don't use the taskENTER_CRITICAL()
		method as that will mask interrupts that should exit sleep mode. */
		__nds32__gie_dis();

		/* If a context switch is pending or a task is waiting for the scheduler
		to be unsuspended then abandon the low power entry. */
		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
		{
			/* Restart from whatever is left in the count register to complete
			this tick period. */
			vSetTickReload( ulRemainTimerCounts );
			vEnableTickInterrupt( pdTRUE );

			/* Reset the reload register to the value required for normal tick
			periods. */
			vSetTickReload( portUL_TIMER_COUNTS_FOR_ONE_TICK );

			/* Re-enable interrupts. */
			__nds32__gie_en();
		}
		else
		{
			/* The tick flag is set to false before sleeping. If it is true when
			sleep mode is exited then sleep mode was probably exited because the
			tick was suppressed for the entire xExpectedIdleTime period. */
			xTickFlag = pdFALSE;

			/* Set the new reload value. */
			vSetTickReload( ulReloadValue );

			/* Restart Timer. */
			vEnableTickInterrupt( pdTRUE );

			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
			set its parameter to 0 to indicate that its implementation contains
			its own wait for interrupt or wait for event instruction, and so wfi
			should not be executed again.  However, the original expected idle
			time variable must remain unmodified, so a copy is taken. */
			xModifiableIdleTime = xExpectedIdleTime;
			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
			if( xModifiableIdleTime > 0 )
			{
				__nds32__standby_no_wake_grant();
			}
			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );

			/* Re-enable interrupts to allow the interrupt that brought the MCU
			out of sleep mode to execute immediately. */
			__nds32__gie_en();

			/* Read the Timer counter and then stop(disable) the Timer. Again,
			The time the Timer is stopped for is accounted for as best it can be,
			but using the tickless mode will inevitably result in some
			tiny drift of the time maintained by the kernel with respect to
			calendar time. */
			ulRemainTimerCounts = ulGetTickCounter();

			/* Disable interrupts again because the clock is about to be stopped
			and interrupts that execute while the clock is stopped will increase
			any slippage between the time maintained by the RTOS and calendar
			time. */
			__nds32__gie_dis();

			/* Determine if the Timer clock has already counted to zero and
			been set back to the current reload value (the reload back being
			correct for the entire expected idle time) or if the Timer is yet
			to count to zero (in which case an interrupt other than the Timer
			must have brought the system out of sleep mode). */
			if( xTickFlag == pdTRUE )
			{
				/* Enable interrupts to allow the Timer interrupt to execute
				immediately. */
				__nds32__gie_en();

				/* Then, disable interrupt for previous reason. */
				__nds32__gie_dis();

				/* Read the Timer counter after Timer overflow. */
				ulRemainTimerCounts = ulGetTickCounter();

				/* Stop Timer. */
				vEnableTickInterrupt( pdFALSE );

				uint32_t ulCalculatedLoadValue;
				/* The tick interrupt is already pending, and the Timer counter
				reloaded with ulReloadValue.  Reset the reload value
				with whatever remains of this tick period. */
				ulCalculatedLoadValue = ( portUL_TIMER_COUNTS_FOR_ONE_TICK - 1UL ) - ( ulReloadValue - ulRemainTimerCounts );

				/* Don't allow a tiny value, or values that have somehow
				underflowed because the post sleep hook did something
				that took too long. */
				if( ( ulCalculatedLoadValue < portUL_STOPPED_TIMER_COMPENSATION ) || ( ulCalculatedLoadValue > portUL_TIMER_COUNTS_FOR_ONE_TICK ) )
				{
					ulCalculatedLoadValue = ( portUL_TIMER_COUNTS_FOR_ONE_TICK - 1UL );
				}

				vSetTickReload( ulCalculatedLoadValue );

				/* As the pending tick will be processed as soon as this
				function exits, the tick value maintained by the tick is stepped
				forward by one less than the time spent waiting. */
				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
			}
			else
			{
				/* Stop Timer. */
				vEnableTickInterrupt( pdFALSE );

				/* Clear Timer interrupt which occurs after GIE disabled */
				vClearTickInterrupt();

				/* Something other than the tick interrupt ended the sleep.
				Work out how long the sleep lasted rounded to complete tick
				periods (not the ulReload value which accounted for part
				ticks). */
				ulCompletedSysTickDecrements = ( xExpectedIdleTime * portUL_TIMER_COUNTS_FOR_ONE_TICK ) - ulRemainTimerCounts;

				/* How many complete tick periods passed while the processor
				was waiting? */
				ulCompleteTickPeriods = ulCompletedSysTickDecrements / portUL_TIMER_COUNTS_FOR_ONE_TICK;

				/* The reload value is set to whatever fraction of a single tick
				period remains. */
				vSetTickReload( ( ( ulCompleteTickPeriods + 1UL ) * portUL_TIMER_COUNTS_FOR_ONE_TICK ) - ulCompletedSysTickDecrements );
			}

			/* Restart Timer so it runs from Timer reload again, then set
			reload value back to its standard value. */
			vEnableTickInterrupt( pdTRUE );
			vTaskStepTick( ulCompleteTickPeriods );
			vSetTickReload( portUL_TIMER_COUNTS_FOR_ONE_TICK );

			/* Exit with interrpts enabled. */
			__nds32__gie_en();
		}
		#endif
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
#if ( configMAX_API_CALL_INTERRUPT_PRIORITY != 0 )
	uint8_t ucCurrentPriority;


		/* Obtain the number of the currently executing interrupt. */
		ucCurrentPriority = ( ( __nds32__mfsr( NDS32_SR_PSW ) & portPSW_CPL_MASK ) >> 16UL );

		/* The following assertion will fail if a service routine (ISR) for
		an interrupt that has been assigned a priority above
		configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
		function.  ISR safe FreeRTOS API functions must *only* be called
		from interrupts that have been assigned a priority at or below
		configMAX_SYSCALL_INTERRUPT_PRIORITY.

		Numerically low interrupt priority numbers represent logically high
		interrupt priorities, therefore the priority of the interrupt must
		be set to a value equal to or numerically *higher* than
		configMAX_SYSCALL_INTERRUPT_PRIORITY.

		FreeRTOS maintains separate thread and ISR API functions to ensure
		interrupt entry is as fast and simple as possible. */
		configASSERT( ucCurrentPriority >= configMAX_API_CALL_INTERRUPT_PRIORITY );
#endif
	}

#endif /* configASSERT_DEFINED */


/* configUSE_STATIC_ALLOCATION is set to 1, so the application must provide an
implementation of vApplicationGetIdleTaskMemory() to provide the memory that is
used by the Idle task. */
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
/* If the buffers to be provided to the Idle task are declared inside this
function then they must be declared static - otherwise they will be allocated on
the stack and so not exists after this function exits. */
static StaticTask_t xIdleTaskTCB;
static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

	/* Pass out a pointer to the StaticTask_t structure in which the Idle task's
	state will be stored. */
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;

	/* Pass out the array that will be used as the Idle task's stack. */
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;

	/* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}


/* configUSE_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the
application must provide an implementation of vApplicationGetTimerTaskMemory()
to provide the memory that is used by the Timer service task. */
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )
{
/* If the buffers to be provided to the Timer task are declared inside this
function then they must be declared static - otherwise they will be allocated on
the stack and so not exists after this function exits. */
static StaticTask_t xTimerTaskTCB;
static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

	/* Pass out a pointer to the StaticTask_t structure in which the Timer
	task's state will be stored. */
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;

	/* Pass out the array that will be used as the Timer task's stack. */
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;

	/* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
}

extern unsigned char buf_start_0[];
extern unsigned char buf_start_1[];
extern unsigned char buf_start_2[];
extern unsigned char buf_len_0[];
extern unsigned char buf_len_1[];
extern unsigned char buf_len_2[];

HeapRegion_t sysHeap[] = 
{
	{buf_start_0, (size_t)buf_len_0}, 
	{buf_start_1, (size_t)buf_len_1},
	{buf_start_2, (size_t)buf_len_2},	
	{0,0}
};
	
void vPortHeapInit(void)
{
	vPortDefineHeapRegions(sysHeap);
}

int mem_is_in_heap(void *mem)
{
	size_t xDefinedRegions=0;

	HeapRegion_t *pxHeapRegion = &sysHeap[xDefinedRegions];
	
	while( pxHeapRegion->xSizeInBytes > 0 )
	{
		if((size_t)mem>= (size_t)pxHeapRegion->pucStartAddress && (size_t)mem<= (size_t)pxHeapRegion->pucStartAddress+(size_t)pxHeapRegion->xSizeInBytes)
		{
					return 1;
		}		 
		xDefinedRegions++;
		pxHeapRegion = &( sysHeap[ xDefinedRegions ] );
	}
	return 0;

}
	
	



